/*
 *  FIPS-197 compliant AES implementation
 *
 *  Based on XySSL: Copyright (C) 2006-2008  Christophe Devine
 *
 *  Copyright (C) 2009  Paul Bakker <polarssl_maintainer at polarssl dot org>
 *
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the names of PolarSSL or XySSL nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 *  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
  *  The AES block cipher was designed by Vincent Rijmen and Joan Daemen.
  *
  *  http://csrc.nist.gov/encryption/aes/rijndael/Rijndael.pdf
  *  http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf
  */

#include "tropicssl/config.h"
#include "avr/pgmspace.h"

#if defined(TROPICSSL_AES_C)

#include "tropicssl/aes.h"
#include "tropicssl/padlock.h"

#include <string.h>

  /*
   * 32-bit integer manipulation macros (little endian)
   */
#ifndef GET_ULONG_LE
#define GET_ULONG_LE(n,b,i)                             \
{                                                       \
    (n) = ( (unsigned long) (b)[(i)    ]       )        \
        | ( (unsigned long) (b)[(i) + 1] <<  8 )        \
        | ( (unsigned long) (b)[(i) + 2] << 16 )        \
        | ( (unsigned long) (b)[(i) + 3] << 24 );       \
}
#endif

#ifndef PUT_ULONG_LE
#define PUT_ULONG_LE(n,b,i)                             \
{                                                       \
    (b)[(i)    ] = (unsigned char) ( (n)       );       \
    (b)[(i) + 1] = (unsigned char) ( (n) >>  8 );       \
    (b)[(i) + 2] = (unsigned char) ( (n) >> 16 );       \
    (b)[(i) + 3] = (unsigned char) ( (n) >> 24 );       \
}
#endif

#if defined(TROPICSSL_AES_ROM_TABLES)
   /*
	* Forward S-box
	*/
static const unsigned char PROGMEM FSb[256] = {
	0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
	0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
	0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
	0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
	0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
	0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
	0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
	0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
	0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
	0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
	0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
	0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
	0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
	0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
	0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
	0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
	0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
	0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
	0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
	0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
	0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
	0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
	0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
	0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
	0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
	0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
	0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
	0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
	0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
	0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
	0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
	0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
};

/*
 * Forward tables
 */
static const unsigned long PROGMEM FT0[256] = {
	0x63C6, 0x7CF8, 0x77EE, 0x7BF6, 0xF2FF, 0x6BD6, 0x6FDE, 0xC591,
	0x3060, 0x102, 0x67CE, 0x2B56, 0xFEE7, 0xD7B5, 0xAB4D, 0x76EC,
	0xCA8F, 0x821F, 0xC989, 0x7DFA, 0xFAEF, 0x59B2, 0x478E, 0xF0FB,
	0xAD41, 0xD4B3, 0xA25F, 0xAF45, 0x9C23, 0xA453, 0x72E4, 0xC09B,
	0xB775, 0xFDE1, 0x933D, 0x264C, 0x366C, 0x3F7E, 0xF7F5, 0xCC83,
	0x3468, 0xA551, 0xE5D1, 0xF1F9, 0x71E2, 0xD8AB, 0x3162, 0x152A,
	0x408, 0xC795, 0x2346, 0xC39D, 0x1830, 0x9637, 0x50A, 0x9A2F,
	0x70E, 0x1224, 0x801B, 0xE2DF, 0xEBCD, 0x274E, 0xB27F, 0x75EA,
	0x912, 0x831D, 0x2C58, 0x1A34, 0x1B36, 0x6EDC, 0x5AB4, 0xA05B,
	0x52A4, 0x3B76, 0xD6B7, 0xB37D, 0x2952, 0xE3DD, 0x2F5E, 0x8413,
	0x53A6, 0xD1B9, 0x0, 0xEDC1, 0x2040, 0xFCE3, 0xB179, 0x5BB6,
	0x6AD4, 0xCB8D, 0xBE67, 0x3972, 0x4A94, 0x4C98, 0x58B0, 0xCF85,
	0xD0BB, 0xEFC5, 0xAA4F, 0xFBED, 0x4386, 0x4D9A, 0x3366, 0x8511,
	0x458A, 0xF9E9, 0x204, 0x7FFE, 0x50A0, 0x3C78, 0x9F25, 0xA84B,
	0x51A2, 0xA35D, 0x4080, 0x8F05, 0x923F, 0x9D21, 0x3870, 0xF5F1,
	0xBC63, 0xB677, 0xDAAF, 0x2142, 0x1020, 0xFFE5, 0xF3FD, 0xD2BF,
	0xCD81, 0xC18, 0x1326, 0xECC3, 0x5FBE, 0x9735, 0x4488, 0x172E,
	0xC493, 0xA755, 0x7EFC, 0x3D7A, 0x64C8, 0x5DBA, 0x1932, 0x73E6,
	0x60C0, 0x8119, 0x4F9E, 0xDCA3, 0x2244, 0x2A54, 0x903B, 0x880B,
	0x468C, 0xEEC7, 0xB86B, 0x1428, 0xDEA7, 0x5EBC, 0xB16, 0xDBAD,
	0xE0DB, 0x3264, 0x3A74, 0xA14, 0x4992, 0x60C, 0x2448, 0x5CB8,
	0xC29F, 0xD3BD, 0xAC43, 0x62C4, 0x9139, 0x9531, 0xE4D3, 0x79F2,
	0xE7D5, 0xC88B, 0x376E, 0x6DDA, 0x8D01, 0xD5B1, 0x4E9C, 0xA949,
	0x6CD8, 0x56AC, 0xF4F3, 0xEACF, 0x65CA, 0x7AF4, 0xAE47, 0x810,
	0xBA6F, 0x78F0, 0x254A, 0x2E5C, 0x1C38, 0xA657, 0xB473, 0xC697,
	0xE8CB, 0xDDA1, 0x74E8, 0x1F3E, 0x4B96, 0xBD61, 0x8B0D, 0x8A0F,
	0x70E0, 0x3E7C, 0xB571, 0x66CC, 0x4890, 0x306, 0xF6F7, 0xE1C,
	0x61C2, 0x356A, 0x57AE, 0xB969, 0x8617, 0xC199, 0x1D3A, 0x9E27,
	0xE1D9, 0xF8EB, 0x982B, 0x1122, 0x69D2, 0xD9A9, 0x8E07, 0x9433,
	0x9B2D, 0x1E3C, 0x8715, 0xE9C9, 0xCE87, 0x55AA, 0x2850, 0xDFA5,
	0x8C03, 0xA159, 0x8909, 0xD1A, 0xBF65, 0xE6D7, 0x4284, 0x68D0,
	0x4182, 0x9929, 0x2D5A, 0xF1E, 0xB07B, 0x54A8, 0xBB6D, 0x162C
};

static const unsigned long PROGMEM FT1[256] = {
	0xC6A5, 0xF884, 0xEE99, 0xF68D, 0xFF0D, 0xD6BD, 0xDEB1, 0x9154,
	0x6050, 0x203, 0xCEA9, 0x567D, 0xE719, 0xB562, 0x4DE6, 0xEC9A,
	0x8F45, 0x1F9D, 0x8940, 0xFA87, 0xEF15, 0xB2EB, 0x8EC9, 0xFB0B,
	0x41EC, 0xB367, 0x5FFD, 0x45EA, 0x23BF, 0x53F7, 0xE496, 0x9B5B,
	0x75C2, 0xE11C, 0x3DAE, 0x4C6A, 0x6C5A, 0x7E41, 0xF502, 0x834F,
	0x685C, 0x51F4, 0xD134, 0xF908, 0xE293, 0xAB73, 0x6253, 0x2A3F,
	0x80C, 0x9552, 0x4665, 0x9D5E, 0x3028, 0x37A1, 0xA0F, 0x2FB5,
	0xE09, 0x2436, 0x1B9B, 0xDF3D, 0xCD26, 0x4E69, 0x7FCD, 0xEA9F,
	0x121B, 0x1D9E, 0x5874, 0x342E, 0x362D, 0xDCB2, 0xB4EE, 0x5BFB,
	0xA4F6, 0x764D, 0xB761, 0x7DCE, 0x527B, 0xDD3E, 0x5E71, 0x1397,
	0xA6F5, 0xB968, 0x0, 0xC12C, 0x4060, 0xE31F, 0x79C8, 0xB6ED,
	0xD4BE, 0x8D46, 0x67D9, 0x724B, 0x94DE, 0x98D4, 0xB0E8, 0x854A,
	0xBB6B, 0xC52A, 0x4FE5, 0xED16, 0x86C5, 0x9AD7, 0x6655, 0x1194,
	0x8ACF, 0xE910, 0x406, 0xFE81, 0xA0F0, 0x7844, 0x25BA, 0x4BE3,
	0xA2F3, 0x5DFE, 0x80C0, 0x58A, 0x3FAD, 0x21BC, 0x7048, 0xF104,
	0x63DF, 0x77C1, 0xAF75, 0x4263, 0x2030, 0xE51A, 0xFD0E, 0xBF6D,
	0x814C, 0x1814, 0x2635, 0xC32F, 0xBEE1, 0x35A2, 0x88CC, 0x2E39,
	0x9357, 0x55F2, 0xFC82, 0x7A47, 0xC8AC, 0xBAE7, 0x322B, 0xE695,
	0xC0A0, 0x1998, 0x9ED1, 0xA37F, 0x4466, 0x547E, 0x3BAB, 0xB83,
	0x8CCA, 0xC729, 0x6BD3, 0x283C, 0xA779, 0xBCE2, 0x161D, 0xAD76,
	0xDB3B, 0x6456, 0x744E, 0x141E, 0x92DB, 0xC0A, 0x486C, 0xB8E4,
	0x9F5D, 0xBD6E, 0x43EF, 0xC4A6, 0x39A8, 0x31A4, 0xD337, 0xF28B,
	0xD532, 0x8B43, 0x6E59, 0xDAB7, 0x18C, 0xB164, 0x9CD2, 0x49E0,
	0xD8B4, 0xACFA, 0xF307, 0xCF25, 0xCAAF, 0xF48E, 0x47E9, 0x1018,
	0x6FD5, 0xF088, 0x4A6F, 0x5C72, 0x3824, 0x57F1, 0x73C7, 0x9751,
	0xCB23, 0xA17C, 0xE89C, 0x3E21, 0x96DD, 0x61DC, 0xD86, 0xF85,
	0xE090, 0x7C42, 0x71C4, 0xCCAA, 0x90D8, 0x605, 0xF701, 0x1C12,
	0xC2A3, 0x6A5F, 0xAEF9, 0x69D0, 0x1791, 0x9958, 0x3A27, 0x27B9,
	0xD938, 0xEB13, 0x2BB3, 0x2233, 0xD2BB, 0xA970, 0x789, 0x33A7,
	0x2DB6, 0x3C22, 0x1592, 0xC920, 0x8749, 0xAAFF, 0x5078, 0xA57A,
	0x38F, 0x59F8, 0x980, 0x1A17, 0x65DA, 0xD731, 0x84C6, 0xD0B8,
	0x82C3, 0x29B0, 0x5A77, 0x1E11, 0x7BCB, 0xA8FC, 0x6DD6, 0x2C3A
};

static const unsigned long PROGMEM FT2[256] = {
	0xA563, 0x847C, 0x9977, 0x8D7B, 0xDF2, 0xBD6B, 0xB16F, 0x54C5,
	0x5030, 0x301, 0xA967, 0x7D2B, 0x19FE, 0x62D7, 0xE6AB, 0x9A76,
	0x45CA, 0x9D82, 0x40C9, 0x877D, 0x15FA, 0xEB59, 0xC947, 0xBF0,
	0xECAD, 0x67D4, 0xFDA2, 0xEAAF, 0xBF9C, 0xF7A4, 0x9672, 0x5BC0,
	0xC2B7, 0x1CFD, 0xAE93, 0x6A26, 0x5A36, 0x413F, 0x2F7, 0x4FCC,
	0x5C34, 0xF4A5, 0x34E5, 0x8F1, 0x9371, 0x73D8, 0x5331, 0x3F15,
	0xC04, 0x52C7, 0x6523, 0x5EC3, 0x2818, 0xA196, 0xF05, 0xB59A,
	0x907, 0x3612, 0x9B80, 0x3DE2, 0x26EB, 0x6927, 0xCDB2, 0x9F75,
	0x1B09, 0x9E83, 0x742C, 0x2E1A, 0x2D1B, 0xB26E, 0xEE5A, 0xFBA0,
	0xF652, 0x4D3B, 0x61D6, 0xCEB3, 0x7B29, 0x3EE3, 0x712F, 0x9784,
	0xF553, 0x68D1, 0x0, 0x2CED, 0x6020, 0x1FFC, 0xC8B1, 0xED5B,
	0xBE6A, 0x46CB, 0xD9BE, 0x4B39, 0xDE4A, 0xD44C, 0xE858, 0x4ACF,
	0x6BD0, 0x2AEF, 0xE5AA, 0x16FB, 0xC543, 0xD74D, 0x5533, 0x9485,
	0xCF45, 0x10F9, 0x602, 0x817F, 0xF050, 0x443C, 0xBA9F, 0xE3A8,
	0xF351, 0xFEA3, 0xC040, 0x8A8F, 0xAD92, 0xBC9D, 0x4838, 0x4F5,
	0xDFBC, 0xC1B6, 0x75DA, 0x6321, 0x3010, 0x1AFF, 0xEF3, 0x6DD2,
	0x4CCD, 0x140C, 0x3513, 0x2FEC, 0xE15F, 0xA297, 0xCC44, 0x3917,
	0x57C4, 0xF2A7, 0x827E, 0x473D, 0xAC64, 0xE75D, 0x2B19, 0x9573,
	0xA060, 0x9881, 0xD14F, 0x7FDC, 0x6622, 0x7E2A, 0xAB90, 0x8388,
	0xCA46, 0x29EE, 0xD3B8, 0x3C14, 0x79DE, 0xE25E, 0x1D0B, 0x76DB,
	0x3BE0, 0x5632, 0x4E3A, 0x1E0A, 0xDB49, 0xA06, 0x6C24, 0xE45C,
	0x5DC2, 0x6ED3, 0xEFAC, 0xA662, 0xA891, 0xA495, 0x37E4, 0x8B79,
	0x32E7, 0x43C8, 0x5937, 0xB76D, 0x8C8D, 0x64D5, 0xD24E, 0xE0A9,
	0xB46C, 0xFA56, 0x7F4, 0x25EA, 0xAF65, 0x8E7A, 0xE9AE, 0x1808,
	0xD5BA, 0x8878, 0x6F25, 0x722E, 0x241C, 0xF1A6, 0xC7B4, 0x51C6,
	0x23E8, 0x7CDD, 0x9C74, 0x211F, 0xDD4B, 0xDCBD, 0x868B, 0x858A,
	0x9070, 0x423E, 0xC4B5, 0xAA66, 0xD848, 0x503, 0x1F6, 0x120E,
	0xA361, 0x5F35, 0xF957, 0xD0B9, 0x9186, 0x58C1, 0x271D, 0xB99E,
	0x38E1, 0x13F8, 0xB398, 0x3311, 0xBB69, 0x70D9, 0x898E, 0xA794,
	0xB69B, 0x221E, 0x9287, 0x20E9, 0x49CE, 0xFF55, 0x7828, 0x7ADF,
	0x8F8C, 0xF8A1, 0x8089, 0x170D, 0xDABF, 0x31E6, 0xC642, 0xB868,
	0xC341, 0xB099, 0x772D, 0x110F, 0xCBB0, 0xFC54, 0xD6BB, 0x3A16
};

static const unsigned long PROGMEM FT3[256] = {
	0x6363, 0x7C7C, 0x7777, 0x7B7B, 0xF2F2, 0x6B6B, 0x6F6F, 0xC5C5,
	0x3030, 0x101, 0x6767, 0x2B2B, 0xFEFE, 0xD7D7, 0xABAB, 0x7676,
	0xCACA, 0x8282, 0xC9C9, 0x7D7D, 0xFAFA, 0x5959, 0x4747, 0xF0F0,
	0xADAD, 0xD4D4, 0xA2A2, 0xAFAF, 0x9C9C, 0xA4A4, 0x7272, 0xC0C0,
	0xB7B7, 0xFDFD, 0x9393, 0x2626, 0x3636, 0x3F3F, 0xF7F7, 0xCCCC,
	0x3434, 0xA5A5, 0xE5E5, 0xF1F1, 0x7171, 0xD8D8, 0x3131, 0x1515,
	0x404, 0xC7C7, 0x2323, 0xC3C3, 0x1818, 0x9696, 0x505, 0x9A9A,
	0x707, 0x1212, 0x8080, 0xE2E2, 0xEBEB, 0x2727, 0xB2B2, 0x7575,
	0x909, 0x8383, 0x2C2C, 0x1A1A, 0x1B1B, 0x6E6E, 0x5A5A, 0xA0A0,
	0x5252, 0x3B3B, 0xD6D6, 0xB3B3, 0x2929, 0xE3E3, 0x2F2F, 0x8484,
	0x5353, 0xD1D1, 0x0, 0xEDED, 0x2020, 0xFCFC, 0xB1B1, 0x5B5B,
	0x6A6A, 0xCBCB, 0xBEBE, 0x3939, 0x4A4A, 0x4C4C, 0x5858, 0xCFCF,
	0xD0D0, 0xEFEF, 0xAAAA, 0xFBFB, 0x4343, 0x4D4D, 0x3333, 0x8585,
	0x4545, 0xF9F9, 0x202, 0x7F7F, 0x5050, 0x3C3C, 0x9F9F, 0xA8A8,
	0x5151, 0xA3A3, 0x4040, 0x8F8F, 0x9292, 0x9D9D, 0x3838, 0xF5F5,
	0xBCBC, 0xB6B6, 0xDADA, 0x2121, 0x1010, 0xFFFF, 0xF3F3, 0xD2D2,
	0xCDCD, 0xC0C, 0x1313, 0xECEC, 0x5F5F, 0x9797, 0x4444, 0x1717,
	0xC4C4, 0xA7A7, 0x7E7E, 0x3D3D, 0x6464, 0x5D5D, 0x1919, 0x7373,
	0x6060, 0x8181, 0x4F4F, 0xDCDC, 0x2222, 0x2A2A, 0x9090, 0x8888,
	0x4646, 0xEEEE, 0xB8B8, 0x1414, 0xDEDE, 0x5E5E, 0xB0B, 0xDBDB,
	0xE0E0, 0x3232, 0x3A3A, 0xA0A, 0x4949, 0x606, 0x2424, 0x5C5C,
	0xC2C2, 0xD3D3, 0xACAC, 0x6262, 0x9191, 0x9595, 0xE4E4, 0x7979,
	0xE7E7, 0xC8C8, 0x3737, 0x6D6D, 0x8D8D, 0xD5D5, 0x4E4E, 0xA9A9,
	0x6C6C, 0x5656, 0xF4F4, 0xEAEA, 0x6565, 0x7A7A, 0xAEAE, 0x808,
	0xBABA, 0x7878, 0x2525, 0x2E2E, 0x1C1C, 0xA6A6, 0xB4B4, 0xC6C6,
	0xE8E8, 0xDDDD, 0x7474, 0x1F1F, 0x4B4B, 0xBDBD, 0x8B8B, 0x8A8A,
	0x7070, 0x3E3E, 0xB5B5, 0x6666, 0x4848, 0x303, 0xF6F6, 0xE0E,
	0x6161, 0x3535, 0x5757, 0xB9B9, 0x8686, 0xC1C1, 0x1D1D, 0x9E9E,
	0xE1E1, 0xF8F8, 0x9898, 0x1111, 0x6969, 0xD9D9, 0x8E8E, 0x9494,
	0x9B9B, 0x1E1E, 0x8787, 0xE9E9, 0xCECE, 0x5555, 0x2828, 0xDFDF,
	0x8C8C, 0xA1A1, 0x8989, 0xD0D, 0xBFBF, 0xE6E6, 0x4242, 0x6868,
	0x4141, 0x9999, 0x2D2D, 0xF0F, 0xB0B0, 0x5454, 0xBBBB, 0x1616
};

/*
 * Reverse S-box
 */
static const unsigned char PROGMEM RSb[256] = {
	0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
	0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
	0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
	0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
	0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
	0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
	0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
	0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
	0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
	0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
	0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
	0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
	0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
	0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
	0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
	0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
	0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
	0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
	0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
	0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
	0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
	0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
	0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
	0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
	0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
	0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
	0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
	0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
	0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
	0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
	0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
};

/*
 * Reverse tables
 */
static const unsigned long PROGMEM RT0[256] = {
	0xF451, 0x417E, 0x171A, 0x273A, 0xAB3B, 0x9D1F, 0xFAAC, 0xE34B,
	0x3020, 0x76AD, 0xCC88, 0x2F5, 0xE54F, 0x2AC5, 0x3526, 0x62B5,
	0xB1DE, 0xBA25, 0xEA45, 0xFE5D, 0x2FC3, 0x4C81, 0x468D, 0xD36B,
	0x8F03, 0x9215, 0x6DBF, 0x5295, 0xBED4, 0x7458, 0xE049, 0xC98E,
	0xC275, 0x8EF4, 0x5899, 0xB927, 0xE1BE, 0x88F0, 0x20C9, 0xCE7D,
	0xDF63, 0x1AE5, 0x5197, 0x5362, 0x64B1, 0x6BBB, 0x81FE, 0x8F9,
	0x4870, 0x458F, 0xDE94, 0x7B52, 0x73AB, 0x4B72, 0x1FE3, 0x5566,
	0xEBB2, 0xB52F, 0xC586, 0x37D3, 0x2830, 0xBF23, 0x302, 0x16ED,
	0xCF8A, 0x79A7, 0x7F3, 0x694E, 0xDA65, 0x506, 0x34D1, 0xA6C4,
	0x2E34, 0xF3A2, 0x8A05, 0xF6A4, 0x830B, 0x6040, 0x715E, 0x6EBD,
	0x213E, 0xDD96, 0x3EDD, 0xE64D, 0x5491, 0xC471, 0x604, 0x5060,
	0x9819, 0xBDD6, 0x4089, 0xD967, 0xE8B0, 0x8907, 0x19E7, 0xC879,
	0x7CA1, 0x427C, 0x84F8, 0x0, 0x8009, 0x2B32, 0x111E, 0x5A6C,
	0xEFD, 0x850F, 0xAE3D, 0x2D36, 0xF0A, 0x5C68, 0x5B9B, 0x3624,
	0xA0C, 0x5793, 0xEEB4, 0x9B1B, 0xC080, 0xDC61, 0x775A, 0x121C,
	0x93E2, 0xA0C0, 0x223C, 0x1B12, 0x90E, 0x8BF2, 0xB62D, 0x1E14,
	0xF157, 0x75AF, 0x99EE, 0x7FA3, 0x1F7, 0x725C, 0x6644, 0xFB5B,
	0x438B, 0x23CB, 0xEDB6, 0xE4B8, 0x31D7, 0x6342, 0x9713, 0xC684,
	0x4A85, 0xBBD2, 0xF9AE, 0x29C7, 0x9E1D, 0xB2DC, 0x860D, 0xC177,
	0xB32B, 0x70A9, 0x9411, 0xE947, 0xFCA8, 0xF0A0, 0x7D56, 0x3322,
	0x4987, 0x38D9, 0xCA8C, 0xD498, 0xF5A6, 0x7AA5, 0xB7DA, 0xAD3F,
	0x3A2C, 0x7850, 0x5F6A, 0x7E54, 0x8DF6, 0xD890, 0x392E, 0xC382,
	0x5D9F, 0xD069, 0xD56F, 0x25CF, 0xACC8, 0x1810, 0x9CE8, 0x3BDB,
	0x26CD, 0x596E, 0x9AEC, 0x4F83, 0x95E6, 0xFFAA, 0xBC21, 0x15EF,
	0xE7BA, 0x6F4A, 0x9FEA, 0xB029, 0xA431, 0x3F2A, 0xA5C6, 0xA235,
	0x4E74, 0x82FC, 0x90E0, 0xA733, 0x4F1, 0xEC41, 0xCD7F, 0x9117,
	0x4D76, 0xEF43, 0xAACC, 0x96E4, 0xD19E, 0x6A4C, 0x2CC1, 0x6546,
	0x5E9D, 0x8C01, 0x87FA, 0xBFB, 0x67B3, 0xDB92, 0x10E9, 0xD66D,
	0xD79A, 0xA137, 0xF859, 0x13EB, 0xA9CE, 0x61B7, 0x1CE1, 0x477A,
	0xD29C, 0xF255, 0x1418, 0xC773, 0xF753, 0xFD5F, 0x3DDF, 0x4478,
	0xAFCA, 0x68B9, 0x2438, 0xA3C2, 0x1D16, 0xE2BC, 0x3C28, 0xDFF,
	0xA839, 0xC08, 0xB4D8, 0x5664, 0xCB7B, 0x32D5, 0x6C48, 0xB8D0
};

static const unsigned long PROGMEM RT1[256] = {
	0x5150, 0x7E53, 0x1AC3, 0x3A96, 0x3BCB, 0x1FF1, 0xACAB, 0x4B93,
	0x2055, 0xADF6, 0x8891, 0xF525, 0x4FFC, 0xC5D7, 0x2680, 0xB58F,
	0xDE49, 0x2567, 0x4598, 0x5DE1, 0xC302, 0x8112, 0x8DA3, 0x6BC6,
	0x3E7, 0x1595, 0xBFEB, 0x95DA, 0xD42D, 0x58D3, 0x4929, 0x8E44,
	0x756A, 0xF478, 0x996B, 0x27DD, 0xBEB6, 0xF017, 0xC966, 0x7DB4,
	0x6318, 0xE582, 0x9760, 0x6245, 0xB1E0, 0xBB84, 0xFE1C, 0xF994,
	0x7058, 0x8F19, 0x9487, 0x52B7, 0xAB23, 0x72E2, 0xE357, 0x662A,
	0xB207, 0x2F03, 0x869A, 0xD3A5, 0x30F2, 0x23B2, 0x2BA, 0xED5C,
	0x8A2B, 0xA792, 0xF3F0, 0x4EA1, 0x65CD, 0x6D5, 0xD11F, 0xC48A,
	0x349D, 0xA2A0, 0x532, 0xA475, 0xB39, 0x40AA, 0x5E06, 0xBD51,
	0x3EF9, 0x963D, 0xDDAE, 0x4D46, 0x91B5, 0x7105, 0x46F, 0x60FF,
	0x1924, 0xD697, 0x89CC, 0x6777, 0xB0BD, 0x788, 0xE738, 0x79DB,
	0xA147, 0x7CE9, 0xF8C9, 0x0, 0x983, 0x3248, 0x1EAC, 0x6C4E,
	0xFDFB, 0xF56, 0x3D1E, 0x3627, 0xA64, 0x6821, 0x9BD1, 0x243A,
	0xCB1, 0x930F, 0xB4D2, 0x1B9E, 0x804F, 0x61A2, 0x5A69, 0x1C16,
	0xE20A, 0xC0E5, 0x3C43, 0x121D, 0xE0B, 0xF2AD, 0x2DB9, 0x14C8,
	0x5785, 0xAF4C, 0xEEBB, 0xA3FD, 0xF79F, 0x5CBC, 0x44C5, 0x5B34,
	0x8B76, 0xCBDC, 0xB668, 0xB863, 0xD7CA, 0x4210, 0x1340, 0x8420,
	0x857D, 0xD2F8, 0xAE11, 0xC76D, 0x1D4B, 0xDCF3, 0xDEC, 0x77D0,
	0x2B6C, 0xA999, 0x11FA, 0x4722, 0xA8C4, 0xA01A, 0x56D8, 0x22EF,
	0x87C7, 0xD9C1, 0x8CFE, 0x9836, 0xA6CF, 0xA528, 0xDA26, 0x3FA4,
	0x2CE4, 0x500D, 0x6A9B, 0x5462, 0xF6C2, 0x90E8, 0x2E5E, 0x82F5,
	0x9FBE, 0x697C, 0x6FA9, 0xCFB3, 0xC83B, 0x10A7, 0xE86E, 0xDB7B,
	0xCD09, 0x6EF4, 0xEC01, 0x83A8, 0xE665, 0xAA7E, 0x2108, 0xEFE6,
	0xBAD9, 0x4ACE, 0xEAD4, 0x29D6, 0x31AF, 0x2A31, 0xC630, 0x35C0,
	0x7437, 0xFCA6, 0xE0B0, 0x3315, 0xF14A, 0x41F7, 0x7F0E, 0x172F,
	0x768D, 0x434D, 0xCC54, 0xE4DF, 0x9EE3, 0x4C1B, 0xC1B8, 0x467F,
	0x9D04, 0x15D, 0xFA73, 0xFB2E, 0xB35A, 0x9252, 0xE933, 0x6D13,
	0x9A8C, 0x377A, 0x598E, 0xEB89, 0xCEEE, 0xB735, 0xE1ED, 0x7A3C,
	0x9C59, 0x553F, 0x1879, 0x73BF, 0x53EA, 0x5F5B, 0xDF14, 0x7886,
	0xCA81, 0xB93E, 0x382C, 0xC25F, 0x1672, 0xBC0C, 0x288B, 0xFF41,
	0x3971, 0x8DE, 0xD89C, 0x6490, 0x7B61, 0xD570, 0x4874, 0xD042
};

static const unsigned long PROGMEM RT2[256] = {
	0x50A7, 0x5365, 0xC3A4, 0x965E, 0xCB6B, 0xF145, 0xAB58, 0x9303,
	0x55FA, 0xF66D, 0x9176, 0x254C, 0xFCD7, 0xD7CB, 0x8044, 0x8FA3,
	0x495A, 0x671B, 0x980E, 0xE1C0, 0x275, 0x12F0, 0xA397, 0xC6F9,
	0xE75F, 0x959C, 0xEB7A, 0xDA59, 0x2D83, 0xD321, 0x2969, 0x44C8,
	0x6A89, 0x7879, 0x6B3E, 0xDD71, 0xB64F, 0x17AD, 0x66AC, 0xB43A,
	0x184A, 0x8231, 0x6033, 0x457F, 0xE077, 0x84AE, 0x1CA0, 0x942B,
	0x5868, 0x19FD, 0x876C, 0xB7F8, 0x23D3, 0xE202, 0x578F, 0x2AAB,
	0x728, 0x3C2, 0x9A7B, 0xA508, 0xF287, 0xB2A5, 0xBA6A, 0x5C82,
	0x2B1C, 0x92B4, 0xF0F2, 0xA1E2, 0xCDF4, 0xD5BE, 0x1F62, 0x8AFE,
	0x9D53, 0xA055, 0x32E1, 0x75EB, 0x39EC, 0xAAEF, 0x69F, 0x5110,
	0xF98A, 0x3D06, 0xAE05, 0x46BD, 0xB58D, 0x55D, 0x6FD4, 0xFF15,
	0x24FB, 0x97E9, 0xCC43, 0x779E, 0xBD42, 0x888B, 0x385B, 0xDBEE,
	0x470A, 0xE90F, 0xC91E, 0x0, 0x8386, 0x48ED, 0xAC70, 0x4E72,
	0xFBFF, 0x5638, 0x1ED5, 0x2739, 0x64D9, 0x21A6, 0xD154, 0x3A2E,
	0xB167, 0xFE7, 0xD296, 0x9E91, 0x4FC5, 0xA220, 0x694B, 0x161A,
	0xABA, 0xE52A, 0x43E0, 0x1D17, 0xB0D, 0xADC7, 0xB9A8, 0xC8A9,
	0x8519, 0x4C07, 0xBBDD, 0xFD60, 0x9F26, 0xBCF5, 0xC53B, 0x347E,
	0x7629, 0xDCC6, 0x68FC, 0x63F1, 0xCADC, 0x1085, 0x4022, 0x2011,
	0x7D24, 0xF83D, 0x1132, 0x6DA1, 0x4B2F, 0xF330, 0xEC52, 0xD0E3,
	0x6C16, 0x99B9, 0xFA48, 0x2264, 0xC48C, 0x1A3F, 0xD82C, 0xEF90,
	0xC74E, 0xC1D1, 0xFEA2, 0x360B, 0xCF81, 0x28DE, 0x268E, 0xA4BF,
	0xE49D, 0xD92, 0x9BCC, 0x6246, 0xC213, 0xE8B8, 0x5EF7, 0xF5AF,
	0xBE80, 0x7C93, 0xA92D, 0xB312, 0x3B99, 0xA77D, 0x6E63, 0x7BBB,
	0x978, 0xF418, 0x1B7, 0xA89A, 0x656E, 0x7EE6, 0x8CF, 0xE6E8,
	0xD99B, 0xCE36, 0xD409, 0xD67C, 0xAFB2, 0x3123, 0x3094, 0xC066,
	0x37BC, 0xA6CA, 0xB0D0, 0x15D8, 0x4A98, 0xF7DA, 0xE50, 0x2FF6,
	0x8DD6, 0x4DB0, 0x544D, 0xDF04, 0xE3B5, 0x1B88, 0xB81F, 0x7F51,
	0x4EA, 0x5D35, 0x7374, 0x2E41, 0x5A1D, 0x52D2, 0x3356, 0x1347,
	0x8C61, 0x7A0C, 0x8E14, 0x893C, 0xEE27, 0x35C9, 0xEDE5, 0x3CB1,
	0x59DF, 0x3F73, 0x79CE, 0xBF37, 0xEACD, 0x5BAA, 0x146F, 0x86DB,
	0x81F3, 0x3EC4, 0x2C34, 0x5F40, 0x72C3, 0xC25, 0x8B49, 0x4195,
	0x7101, 0xDEB3, 0x9CE4, 0x90C1, 0x6184, 0x70B6, 0x745C, 0x4257
};

static const unsigned long PROGMEM RT3[256] = {
	0xA7F4, 0x6541, 0xA417, 0x5E27, 0x6BAB, 0x459D, 0x58FA, 0x3E3,
	0xFA30, 0x6D76, 0x76CC, 0x4C02, 0xD7E5, 0xCB2A, 0x4435, 0xA362,
	0x5AB1, 0x1BBA, 0xEEA, 0xC0FE, 0x752F, 0xF04C, 0x9746, 0xF9D3,
	0x5F8F, 0x9C92, 0x7A6D, 0x5952, 0x83BE, 0x2174, 0x69E0, 0xC8C9,
	0x89C2, 0x798E, 0x3E58, 0x71B9, 0x4FE1, 0xAD88, 0xAC20, 0x3ACE,
	0x4ADF, 0x311A, 0x3351, 0x7F53, 0x7764, 0xAE6B, 0xA081, 0x2B08,
	0x6848, 0xFD45, 0x6CDE, 0xF87B, 0xD373, 0x24B, 0x8F1F, 0xAB55,
	0x28EB, 0xC2B5, 0x7BC5, 0x837, 0x8728, 0xA5BF, 0x6A03, 0x8216,
	0x1CCF, 0xB479, 0xF207, 0xE269, 0xF4DA, 0xBE05, 0x6234, 0xFEA6,
	0x532E, 0x55F3, 0xE18A, 0xEBF6, 0xEC83, 0xEF60, 0x9F71, 0x106E,
	0x8A21, 0x6DD, 0x53E, 0xBDE6, 0x8D54, 0x5DC4, 0xD406, 0x1550,
	0xFB98, 0xE9BD, 0x4340, 0x9ED9, 0x42E8, 0x8B89, 0x5B19, 0xEEC8,
	0xA7C, 0xF42, 0x1E84, 0x0, 0x8680, 0xED2B, 0x7011, 0x725A,
	0xFF0E, 0x3885, 0xD5AE, 0x392D, 0xD90F, 0xA65C, 0x545B, 0x2E36,
	0x670A, 0xE757, 0x96EE, 0x919B, 0xC5C0, 0x20DC, 0x4B77, 0x1A12,
	0xBA93, 0x2AA0, 0xE022, 0x171B, 0xD09, 0xC78B, 0xA8B6, 0xA91E,
	0x19F1, 0x775, 0xDD99, 0x607F, 0x2601, 0xF572, 0x3B66, 0x7EFB,
	0x2943, 0xC623, 0xFCED, 0xF1E4, 0xDC31, 0x8563, 0x2297, 0x11C6,
	0x244A, 0x3DBB, 0x32F9, 0xA129, 0x2F9E, 0x30B2, 0x5286, 0xE3C1,
	0x16B3, 0xB970, 0x4894, 0x64E9, 0x8CFC, 0x3FF0, 0x2C7D, 0x9033,
	0x4E49, 0xD138, 0xA2CA, 0xBD4, 0x81F5, 0xDE7A, 0x8EB7, 0xBFAD,
	0x9D3A, 0x9278, 0xCC5F, 0x467E, 0x138D, 0xB8D8, 0xF739, 0xAFC3,
	0x805D, 0x93D0, 0x2DD5, 0x1225, 0x99AC, 0x7D18, 0x639C, 0xBB3B,
	0x7826, 0x1859, 0xB79A, 0x9A4F, 0x6E95, 0xE6FF, 0xCFBC, 0xE815,
	0x9BE7, 0x366F, 0x99F, 0x7CB0, 0xB2A4, 0x233F, 0x94A5, 0x66A2,
	0xBC4E, 0xCA82, 0xD090, 0xD8A7, 0x9804, 0xDAEC, 0x50CD, 0xF691,
	0xD64D, 0xB0EF, 0x4DAA, 0x496, 0xB5D1, 0x886A, 0x1F2C, 0x5165,
	0xEA5E, 0x358C, 0x7487, 0x410B, 0x1D67, 0xD2DB, 0x5610, 0x47D6,
	0x61D7, 0xCA1, 0x14F8, 0x3C13, 0x27A9, 0xC961, 0xE51C, 0xB147,
	0xDFD2, 0x73F2, 0xCE14, 0x37C7, 0xCDF7, 0xAAFD, 0x6F3D, 0xDB44,
	0xF3AF, 0xC468, 0x3424, 0x40A3, 0xC31D, 0x25E2, 0x493C, 0x950D,
	0x1A8, 0xB30C, 0xE4B4, 0xC156, 0x84CB, 0xB632, 0x5C6C, 0x57B8
};

/*
 * Round constants
 */
static const unsigned long RCON[10] = {
	0x00000001, 0x00000002, 0x00000004, 0x00000008,
	0x00000010, 0x00000020, 0x00000040, 0x00000080,
	0x0000001B, 0x00000036
};

#else

   /*
	* Forward S-box & tables
	*/
static unsigned char FSb[256];
static unsigned long FT0[256];
static unsigned long FT1[256];
static unsigned long FT2[256];
static unsigned long FT3[256];

/*
 * Reverse S-box & tables
 */
static unsigned char RSb[256];
static unsigned long RT0[256];
static unsigned long RT1[256];
static unsigned long RT2[256];
static unsigned long RT3[256];

/*
 * Round constants
 */
static unsigned long RCON[10];

/*
 * Tables generation code
 */
#define ROTL8(x) ( ( x << 8 ) & 0xFFFFFFFF ) | ( x >> 24 )
#define XTIME(x) ( ( x << 1 ) ^ ( ( x & 0x80 ) ? 0x1B : 0x00 ) )
#define MUL(x,y) ( ( x && y ) ? pow[(log[x]+log[y]) % 255] : 0 )

static int aes_init_done = 0;

static void aes_gen_tables(void)
{
	int i, x, y, z;
	int pow[256];
	int log[256];

	/*
	 * compute pow and log tables over GF(2^8)
	 */
	for (i = 0, x = 1; i < 256; i++) {
		pow[i] = x;
		log[x] = i;
		x = (x ^ XTIME(x)) & 0xFF;
	}

	/*
	 * calculate the round constants
	 */
	for (i = 0, x = 1; i < 10; i++) {
		RCON[i] = (unsigned long)x;
		x = XTIME(x) & 0xFF;
	}

	/*
	 * generate the forward and reverse S-boxes
	 */
	FSb[0x00] = 0x63;
	RSb[0x63] = 0x00;

	for (i = 1; i < 256; i++) {
		x = pow[255 - log[i]];

		y = x;
		y = ((y << 1) | (y >> 7)) & 0xFF;
		x ^= y;
		y = ((y << 1) | (y >> 7)) & 0xFF;
		x ^= y;
		y = ((y << 1) | (y >> 7)) & 0xFF;
		x ^= y;
		y = ((y << 1) | (y >> 7)) & 0xFF;
		x ^= y ^ 0x63;

		FSb[i] = (unsigned char)x;
		RSb[x] = (unsigned char)i;
	}

	/*
	 * generate the forward and reverse tables
	 */
	for (i = 0; i < 256; i++) {
		x = FSb[i];
		y = XTIME(x) & 0xFF;
		z = (y ^ x) & 0xFF;

		FT0[i] = ((unsigned long)y) ^
			((unsigned long)x << 8) ^
			((unsigned long)x << 16) ^ ((unsigned long)z << 24);

		FT1[i] = ROTL8(FT0[i]);
		FT2[i] = ROTL8(FT1[i]);
		FT3[i] = ROTL8(FT2[i]);

		x = RSb[i];

		RT0[i] = ((unsigned long)MUL(0x0E, x)) ^
			((unsigned long)MUL(0x09, x) << 8) ^
			((unsigned long)MUL(0x0D, x) << 16) ^
			((unsigned long)MUL(0x0B, x) << 24);

		RT1[i] = ROTL8(RT0[i]);
		RT2[i] = ROTL8(RT1[i]);
		RT3[i] = ROTL8(RT2[i]);
	}
}

#endif

/*
 * AES key schedule (encryption)
 */
void aes_setkey_enc(aes_context * ctx, unsigned char *key, int keysize)
{
	int i;
	unsigned long *RK;
	int temp[4] = { 0 };

#if !defined(TROPICSSL_AES_ROM_TABLES)
	if (aes_init_done == 0) {
		aes_gen_tables();
		aes_init_done = 1;
	}
#endif

	switch (keysize) {
	case 128:
		ctx->nr = 10;
		break;
	case 192:
		ctx->nr = 12;
		break;
	case 256:
		ctx->nr = 14;
		break;
	default:
		return;
	}

#if defined(PADLOCK_ALIGN16)
	ctx->rk = RK = PADLOCK_ALIGN16(ctx->buf);
#else
	ctx->rk = RK = ctx->buf;
#endif

	for (i = 0; i < (keysize >> 5); i++) {
		GET_ULONG_LE(RK[i], key, i << 2);
	}
	
	switch (ctx->nr) {
	case 10:

		temp[0] = (RK[3] >> 8) & 0xFF;
		temp[1] = (RK[3] >> 16) & 0xFF;
		temp[2] = (RK[3] >> 24) & 0xFF;
		temp[3] = (RK[3]) & 0xFF;

		for (i = 0; i < 10; i++, RK += 4) {
			RK[4] = RK[0] ^ RCON[i] ^
				((unsigned long)pgm_read_dword(FSb[temp[0]])) ^ 
				((unsigned long)pgm_read_dword(FSb[temp[1]] << 8)) ^
				((unsigned long)pgm_read_dword(FSb[temp[2]] << 16)) ^
				((unsigned long)pgm_read_dword(FSb[temp[3]] << 24));

			RK[5] = RK[1] ^ RK[4];
			RK[6] = RK[2] ^ RK[5];
			RK[7] = RK[3] ^ RK[6];
		}
		break;

	case 12:

		temp[0] = (RK[5] >> 8) & 0xFF;
		temp[1] = (RK[5] >> 16) & 0xFF;
		temp[2] = (RK[5] >> 24) & 0xFF;
		temp[3] = (RK[5]) & 0xFF;

		for (i = 0; i < 8; i++, RK += 6) {
			RK[6] = RK[0] ^ RCON[i] ^
				((unsigned long)pgm_read_dword(FSb[temp[0]])) ^
				((unsigned long)pgm_read_dword(FSb[temp[1]] << 8)) ^
				((unsigned long)pgm_read_dword(FSb[temp[2]] << 16)) ^
				((unsigned long)pgm_read_dword(FSb[temp[3]] << 24));

			RK[7] = RK[1] ^ RK[6];
			RK[8] = RK[2] ^ RK[7];
			RK[9] = RK[3] ^ RK[8];
			RK[10] = RK[4] ^ RK[9];
			RK[11] = RK[5] ^ RK[10];
		}
		break;

	case 14:

		temp[0] = (RK[7] >> 8) & 0xFF;
		temp[1] = (RK[7] >> 16) & 0xFF;
		temp[2] = (RK[7] >> 24) & 0xFF;
		temp[3] = (RK[7]) & 0xFF;

		for (i = 0; i < 7; i++, RK += 8) {
			RK[8] = RK[0] ^ RCON[i] ^
				((unsigned long)pgm_read_dword(FSb[temp[0]])) ^
				((unsigned long)pgm_read_dword(FSb[temp[1]] << 8)) ^
				((unsigned long)pgm_read_dword(FSb[temp[2]] << 16)) ^
				((unsigned long)pgm_read_dword(FSb[temp[3]] << 24));

			RK[9] = RK[1] ^ RK[8];
			RK[10] = RK[2] ^ RK[9];
			RK[11] = RK[3] ^ RK[10];

			RK[12] = RK[4] ^
				((unsigned long)pgm_read_dword(FSb[(RK[11]) & 0xFF])) ^
				((unsigned long)pgm_read_dword(FSb[(RK[11] >> 8) & 0xFF]) << 8) ^
				((unsigned long)pgm_read_dword(FSb[(RK[11] >> 16) & 0xFF]) << 16) ^
				((unsigned long)pgm_read_dword(FSb[(RK[11] >> 24) & 0xFF]) << 24);

			RK[13] = RK[5] ^ RK[12];
			RK[14] = RK[6] ^ RK[13];
			RK[15] = RK[7] ^ RK[14];
		}
		break;

	default:

		break;
	}
}

/*
 * AES key schedule (decryption)
 */
void aes_setkey_dec(aes_context * ctx, unsigned char *key, int keysize)
{
	int i, j;
	aes_context cty;
	unsigned long *RK;
	unsigned long *SK;

	switch (keysize) {
	case 128:
		ctx->nr = 10;
		break;
	case 192:
		ctx->nr = 12;
		break;
	case 256:
		ctx->nr = 14;
		break;
	default:
		return;
	}

#if defined(PADLOCK_ALIGN16)
	ctx->rk = RK = PADLOCK_ALIGN16(ctx->buf);
#else
	ctx->rk = RK = ctx->buf;
#endif

	aes_setkey_enc(&cty, key, keysize);
	SK = cty.rk + cty.nr * 4;

	*RK++ = *SK++;
	*RK++ = *SK++;
	*RK++ = *SK++;
	*RK++ = *SK++;

	for (i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8) {
		for (j = 0; j < 4; j++, SK++) {
			*RK++ = pgm_read_dword(RT0[pgm_read_dword(FSb[(*SK) & 0xFF])]) ^
				pgm_read_dword(RT1[pgm_read_dword(FSb[(*SK >> 8) & 0xFF])]) ^
				pgm_read_dword(RT2[pgm_read_dword(FSb[(*SK >> 16) & 0xFF])]) ^
				pgm_read_dword(RT3[pgm_read_dword(FSb[(*SK >> 24) & 0xFF])]);
		}
	}

	*RK++ = *SK++;
	*RK++ = *SK++;
	*RK++ = *SK++;
	*RK++ = *SK++;

	memset(&cty, 0, sizeof(aes_context));
}

#define AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \
{                                               \
    X0 = *RK++ ^ pgm_read_dword(FT0[ ( Y0       ) & 0xFF ]) ^   \
                 pgm_read_dword(FT1[ ( Y1 >>  8 ) & 0xFF ]) ^   \
                 pgm_read_dword(FT2[ ( Y2 >> 16 ) & 0xFF ]) ^   \
                 pgm_read_dword(FT3[ ( Y3 >> 24 ) & 0xFF ]);    \
                                                \
    X1 = *RK++ ^ pgm_read_dword(FT0[ ( Y1       ) & 0xFF ]) ^   \
                 pgm_read_dword(FT1[ ( Y2 >>  8 ) & 0xFF ]) ^   \
                 pgm_read_dword(FT2[ ( Y3 >> 16 ) & 0xFF ]) ^   \
                 pgm_read_dword(FT3[ ( Y0 >> 24 ) & 0xFF ]);    \
                                                \
    X2 = *RK++ ^ pgm_read_dword(FT0[ ( Y2       ) & 0xFF ]) ^   \
                 pgm_read_dword(FT1[ ( Y3 >>  8 ) & 0xFF ]) ^   \
                 pgm_read_dword(FT2[ ( Y0 >> 16 ) & 0xFF ]) ^   \
                 pgm_read_dword(FT3[ ( Y1 >> 24 ) & 0xFF ]);    \
                                                \
    X3 = *RK++ ^ pgm_read_dword(FT0[ ( Y3       ) & 0xFF ]) ^   \
                 pgm_read_dword(FT1[ ( Y0 >>  8 ) & 0xFF ]) ^   \
                 pgm_read_dword(FT2[ ( Y1 >> 16 ) & 0xFF ]) ^   \
                 pgm_read_dword(FT3[ ( Y2 >> 24 ) & 0xFF ]);    \
}

#define AES_RROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \
{                                               \
    X0 = *RK++ ^ pgm_read_dword(RT0[ ( Y0       ) & 0xFF ]) ^   \
                 pgm_read_dword(RT1[ ( Y3 >>  8 ) & 0xFF ]) ^   \
                 pgm_read_dword(RT2[ ( Y2 >> 16 ) & 0xFF ]) ^   \
                 pgm_read_dword(RT3[ ( Y1 >> 24 ) & 0xFF ]);    \
                                                \
    X1 = *RK++ ^ pgm_read_dword(RT0[ ( Y1       ) & 0xFF ]) ^   \
                 pgm_read_dword(RT1[ ( Y0 >>  8 ) & 0xFF ]) ^   \
                 pgm_read_dword(RT2[ ( Y3 >> 16 ) & 0xFF ]) ^   \
                 pgm_read_dword(RT3[ ( Y2 >> 24 ) & 0xFF ]);    \
                                                \
    X2 = *RK++ ^ pgm_read_dword(RT0[ ( Y2       ) & 0xFF ]) ^   \
                 pgm_read_dword(RT1[ ( Y1 >>  8 ) & 0xFF ]) ^   \
                 pgm_read_dword(RT2[ ( Y0 >> 16 ) & 0xFF ]) ^   \
                 pgm_read_dword(RT3[ ( Y3 >> 24 ) & 0xFF ]);    \
                                                \
    X3 = *RK++ ^ pgm_read_dword(RT0[ ( Y3       ) & 0xFF ]) ^   \
                 pgm_read_dword(RT1[ ( Y2 >>  8 ) & 0xFF ]) ^   \
                 pgm_read_dword(RT2[ ( Y1 >> 16 ) & 0xFF ]) ^   \
                 pgm_read_dword(RT3[ ( Y0 >> 24 ) & 0xFF ]);    \
}

/*
 * AES-ECB block encryption/decryption
 */
void aes_crypt_ecb(aes_context * ctx,
	int mode, unsigned char input[16], unsigned char output[16])
{
	int i;
	unsigned long *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

#if defined(TROPICSSL_PADLOCK_C) && defined(TROPICSSL_HAVE_X86)
	if (padlock_supports(PADLOCK_ACE)) {
		if (padlock_xcryptecb(ctx, mode, input, output) == 0)
			return;
	}
#endif

	RK = ctx->rk;

	GET_ULONG_LE(X0, input, 0);
	X0 ^= *RK++;
	GET_ULONG_LE(X1, input, 4);
	X1 ^= *RK++;
	GET_ULONG_LE(X2, input, 8);
	X2 ^= *RK++;
	GET_ULONG_LE(X3, input, 12);
	X3 ^= *RK++;

	if (mode == AES_DECRYPT) {
		for (i = (ctx->nr >> 1) - 1; i > 0; i--) {
			AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
			AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);
		}

		AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);

		X0 = *RK++ ^
			((unsigned long)RSb[(Y0) & 0xFF]) ^
			((unsigned long)RSb[(Y3 >> 8) & 0xFF] << 8) ^
			((unsigned long)RSb[(Y2 >> 16) & 0xFF] << 16) ^
			((unsigned long)RSb[(Y1 >> 24) & 0xFF] << 24);

		X1 = *RK++ ^
			((unsigned long)RSb[(Y1) & 0xFF]) ^
			((unsigned long)RSb[(Y0 >> 8) & 0xFF] << 8) ^
			((unsigned long)RSb[(Y3 >> 16) & 0xFF] << 16) ^
			((unsigned long)RSb[(Y2 >> 24) & 0xFF] << 24);

		X2 = *RK++ ^
			((unsigned long)RSb[(Y2) & 0xFF]) ^
			((unsigned long)RSb[(Y1 >> 8) & 0xFF] << 8) ^
			((unsigned long)RSb[(Y0 >> 16) & 0xFF] << 16) ^
			((unsigned long)RSb[(Y3 >> 24) & 0xFF] << 24);

		X3 = *RK++ ^
			((unsigned long)RSb[(Y3) & 0xFF]) ^
			((unsigned long)RSb[(Y2 >> 8) & 0xFF] << 8) ^
			((unsigned long)RSb[(Y1 >> 16) & 0xFF] << 16) ^
			((unsigned long)RSb[(Y0 >> 24) & 0xFF] << 24);
	}
	else {		/* AES_ENCRYPT */
		for (i = (ctx->nr >> 1) - 1; i > 0; i--) {
			AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
			AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);
		}

		AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);

		X0 = *RK++ ^
			((unsigned long)FSb[(Y0) & 0xFF]) ^
			((unsigned long)FSb[(Y1 >> 8) & 0xFF] << 8) ^
			((unsigned long)FSb[(Y2 >> 16) & 0xFF] << 16) ^
			((unsigned long)FSb[(Y3 >> 24) & 0xFF] << 24);

		X1 = *RK++ ^
			((unsigned long)FSb[(Y1) & 0xFF]) ^
			((unsigned long)FSb[(Y2 >> 8) & 0xFF] << 8) ^
			((unsigned long)FSb[(Y3 >> 16) & 0xFF] << 16) ^
			((unsigned long)FSb[(Y0 >> 24) & 0xFF] << 24);

		X2 = *RK++ ^
			((unsigned long)FSb[(Y2) & 0xFF]) ^
			((unsigned long)FSb[(Y3 >> 8) & 0xFF] << 8) ^
			((unsigned long)FSb[(Y0 >> 16) & 0xFF] << 16) ^
			((unsigned long)FSb[(Y1 >> 24) & 0xFF] << 24);

		X3 = *RK++ ^
			((unsigned long)FSb[(Y3) & 0xFF]) ^
			((unsigned long)FSb[(Y0 >> 8) & 0xFF] << 8) ^
			((unsigned long)FSb[(Y1 >> 16) & 0xFF] << 16) ^
			((unsigned long)FSb[(Y2 >> 24) & 0xFF] << 24);
	}

	PUT_ULONG_LE(X0, output, 0);
	PUT_ULONG_LE(X1, output, 4);
	PUT_ULONG_LE(X2, output, 8);
	PUT_ULONG_LE(X3, output, 12);
}

/*
 * AES-CBC buffer encryption/decryption
 */
void aes_crypt_cbc(aes_context * ctx,
	int mode,
	int length,
	unsigned char iv[16],
	unsigned char *input, unsigned char *output)
{
	int i;
	unsigned char temp[16];

#if defined(TROPICSSL_PADLOCK_C) && defined(TROPICSSL_HAVE_X86)
	if (padlock_supports(PADLOCK_ACE)) {
		if (padlock_xcryptcbc(ctx, mode, length, iv, input, output) ==
			0)
			return;
	}
#endif

	if (mode == AES_DECRYPT) {
		while (length > 0) {
			memcpy(temp, input, 16);
			aes_crypt_ecb(ctx, mode, input, output);

			for (i = 0; i < 16; i++)
				output[i] = (unsigned char)(output[i] ^ iv[i]);

			memcpy(iv, temp, 16);

			input += 16;
			output += 16;
			length -= 16;
		}
	}
	else {
		while (length > 0) {
			for (i = 0; i < 16; i++)
				output[i] = (unsigned char)(input[i] ^ iv[i]);

			aes_crypt_ecb(ctx, mode, output, output);
			memcpy(iv, output, 16);

			input += 16;
			output += 16;
			length -= 16;
		}
	}
}

/*
 * AES-CFB128 buffer encryption/decryption
 */
void aes_crypt_cfb128(aes_context * ctx,
	int mode,
	int length,
	int *iv_off,
	unsigned char iv[16],
	unsigned char *input, unsigned char *output)
{
	int c, n = *iv_off;

	if (mode == AES_DECRYPT) {
		while (length--) {
			if (n == 0)
				aes_crypt_ecb(ctx, AES_ENCRYPT, iv, iv);

			c = *input++;
			*output++ = (unsigned char)(c ^ iv[n]);
			iv[n] = (unsigned char)c;

			n = (n + 1) & 0x0F;
		}
	}
	else {
		while (length--) {
			if (n == 0)
				aes_crypt_ecb(ctx, AES_ENCRYPT, iv, iv);

			iv[n] = *output++ = (unsigned char)(iv[n] ^ *input++);

			n = (n + 1) & 0x0F;
		}
	}

	*iv_off = n;
}

#if defined(TROPICSSL_SELF_TEST)

#include <stdio.h>

/*
 * AES test vectors from:
 *
 * http://csrc.nist.gov/archive/aes/rijndael/rijndael-vals.zip
 */
static const unsigned char aes_test_ecb_dec[3][16] = {
	{
	 0x44, 0x41, 0x6A, 0xC2, 0xD1, 0xF5, 0x3C, 0x58,
	 0x33, 0x03, 0x91, 0x7E, 0x6B, 0xE9, 0xEB, 0xE0},
	{
	 0x48, 0xE3, 0x1E, 0x9E, 0x25, 0x67, 0x18, 0xF2,
	 0x92, 0x29, 0x31, 0x9C, 0x19, 0xF1, 0x5B, 0xA4},
	{
	 0x05, 0x8C, 0xCF, 0xFD, 0xBB, 0xCB, 0x38, 0x2D,
	 0x1F, 0x6F, 0x56, 0x58, 0x5D, 0x8A, 0x4A, 0xDE}
};

static const unsigned char aes_test_ecb_enc[3][16] = {
	{
	 0xC3, 0x4C, 0x05, 0x2C, 0xC0, 0xDA, 0x8D, 0x73,
	 0x45, 0x1A, 0xFE, 0x5F, 0x03, 0xBE, 0x29, 0x7F},
	{
	 0xF3, 0xF6, 0x75, 0x2A, 0xE8, 0xD7, 0x83, 0x11,
	 0x38, 0xF0, 0x41, 0x56, 0x06, 0x31, 0xB1, 0x14},
	{
	 0x8B, 0x79, 0xEE, 0xCC, 0x93, 0xA0, 0xEE, 0x5D,
	 0xFF, 0x30, 0xB4, 0xEA, 0x21, 0x63, 0x6D, 0xA4}
};

static const unsigned char aes_test_cbc_dec[3][16] = {
	{
	 0xFA, 0xCA, 0x37, 0xE0, 0xB0, 0xC8, 0x53, 0x73,
	 0xDF, 0x70, 0x6E, 0x73, 0xF7, 0xC9, 0xAF, 0x86},
	{
	 0x5D, 0xF6, 0x78, 0xDD, 0x17, 0xBA, 0x4E, 0x75,
	 0xB6, 0x17, 0x68, 0xC6, 0xAD, 0xEF, 0x7C, 0x7B},
	{
	 0x48, 0x04, 0xE1, 0x81, 0x8F, 0xE6, 0x29, 0x75,
	 0x19, 0xA3, 0xE8, 0x8C, 0x57, 0x31, 0x04, 0x13}
};

static const unsigned char aes_test_cbc_enc[3][16] = {
	{
	 0x8A, 0x05, 0xFC, 0x5E, 0x09, 0x5A, 0xF4, 0x84,
	 0x8A, 0x08, 0xD3, 0x28, 0xD3, 0x68, 0x8E, 0x3D},
	{
	 0x7B, 0xD9, 0x66, 0xD5, 0x3A, 0xD8, 0xC1, 0xBB,
	 0x85, 0xD2, 0xAD, 0xFA, 0xE8, 0x7B, 0xB1, 0x04},
	{
	 0xFE, 0x3C, 0x53, 0x65, 0x3E, 0x2F, 0x45, 0xB5,
	 0x6F, 0xCD, 0x88, 0xB2, 0xCC, 0x89, 0x8F, 0xF0}
};

/*
 * AES-CFB128 test vectors from:
 *
 * http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
 */
static const unsigned char aes_test_cfb128_key[3][32] = {
	{
	 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
	 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C},
	{
	 0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52,
	 0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5,
	 0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B},
	{
	 0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE,
	 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81,
	 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7,
	 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4}
};

static const unsigned char aes_test_cfb128_iv[16] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};

static const unsigned char aes_test_cfb128_pt[64] = {
	0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
	0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A,
	0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C,
	0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51,
	0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11,
	0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF,
	0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17,
	0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10
};

static const unsigned char aes_test_cfb128_ct[3][64] = {
	{
	 0x3B, 0x3F, 0xD9, 0x2E, 0xB7, 0x2D, 0xAD, 0x20,
	 0x33, 0x34, 0x49, 0xF8, 0xE8, 0x3C, 0xFB, 0x4A,
	 0xC8, 0xA6, 0x45, 0x37, 0xA0, 0xB3, 0xA9, 0x3F,
	 0xCD, 0xE3, 0xCD, 0xAD, 0x9F, 0x1C, 0xE5, 0x8B,
	 0x26, 0x75, 0x1F, 0x67, 0xA3, 0xCB, 0xB1, 0x40,
	 0xB1, 0x80, 0x8C, 0xF1, 0x87, 0xA4, 0xF4, 0xDF,
	 0xC0, 0x4B, 0x05, 0x35, 0x7C, 0x5D, 0x1C, 0x0E,
	 0xEA, 0xC4, 0xC6, 0x6F, 0x9F, 0xF7, 0xF2, 0xE6},
	{
	 0xCD, 0xC8, 0x0D, 0x6F, 0xDD, 0xF1, 0x8C, 0xAB,
	 0x34, 0xC2, 0x59, 0x09, 0xC9, 0x9A, 0x41, 0x74,
	 0x67, 0xCE, 0x7F, 0x7F, 0x81, 0x17, 0x36, 0x21,
	 0x96, 0x1A, 0x2B, 0x70, 0x17, 0x1D, 0x3D, 0x7A,
	 0x2E, 0x1E, 0x8A, 0x1D, 0xD5, 0x9B, 0x88, 0xB1,
	 0xC8, 0xE6, 0x0F, 0xED, 0x1E, 0xFA, 0xC4, 0xC9,
	 0xC0, 0x5F, 0x9F, 0x9C, 0xA9, 0x83, 0x4F, 0xA0,
	 0x42, 0xAE, 0x8F, 0xBA, 0x58, 0x4B, 0x09, 0xFF},
	{
	 0xDC, 0x7E, 0x84, 0xBF, 0xDA, 0x79, 0x16, 0x4B,
	 0x7E, 0xCD, 0x84, 0x86, 0x98, 0x5D, 0x38, 0x60,
	 0x39, 0xFF, 0xED, 0x14, 0x3B, 0x28, 0xB1, 0xC8,
	 0x32, 0x11, 0x3C, 0x63, 0x31, 0xE5, 0x40, 0x7B,
	 0xDF, 0x10, 0x13, 0x24, 0x15, 0xE5, 0x4B, 0x92,
	 0xA1, 0x3E, 0xD0, 0xA8, 0x26, 0x7A, 0xE2, 0xF9,
	 0x75, 0xA3, 0x85, 0x74, 0x1A, 0xB9, 0xCE, 0xF8,
	 0x20, 0x31, 0x62, 0x3D, 0x55, 0xB1, 0xE4, 0x71}
};

/*
 * Checkup routine
 */
int aes_self_test(int verbose)
{
	int i, j, u, v, offset;
	unsigned char key[32];
	unsigned char buf[64];
	unsigned char prv[16];
	unsigned char iv[16];
	aes_context ctx;

	memset(key, 0, 32);

	/*
	 * ECB mode
	 */
	for (i = 0; i < 6; i++) {
		u = i >> 1;
		v = i & 1;

		if (verbose != 0)
			printf("  AES-ECB-%3d (%s): ", 128 + u * 64,
			(v == AES_DECRYPT) ? "dec" : "enc");

		memset(buf, 0, 16);

		if (v == AES_DECRYPT) {
			aes_setkey_dec(&ctx, key, 128 + u * 64);

			for (j = 0; j < 10000; j++)
				aes_crypt_ecb(&ctx, v, buf, buf);

			if (memcmp(buf, aes_test_ecb_dec[u], 16) != 0) {
				if (verbose != 0)
					printf("failed\n");

				return (1);
			}
		}
		else {
			aes_setkey_enc(&ctx, key, 128 + u * 64);

			for (j = 0; j < 10000; j++)
				aes_crypt_ecb(&ctx, v, buf, buf);

			if (memcmp(buf, aes_test_ecb_enc[u], 16) != 0) {
				if (verbose != 0)
					printf("failed\n");

				return (1);
			}
		}

		if (verbose != 0)
			printf("passed\n");
	}

	if (verbose != 0)
		printf("\n");

	/*
	 * CBC mode
	 */
	for (i = 0; i < 6; i++) {
		u = i >> 1;
		v = i & 1;

		if (verbose != 0)
			printf("  AES-CBC-%3d (%s): ", 128 + u * 64,
			(v == AES_DECRYPT) ? "dec" : "enc");

		memset(iv, 0, 16);
		memset(prv, 0, 16);
		memset(buf, 0, 16);

		if (v == AES_DECRYPT) {
			aes_setkey_dec(&ctx, key, 128 + u * 64);

			for (j = 0; j < 10000; j++)
				aes_crypt_cbc(&ctx, v, 16, iv, buf, buf);

			if (memcmp(buf, aes_test_cbc_dec[u], 16) != 0) {
				if (verbose != 0)
					printf("failed\n");

				return (1);
			}
		}
		else {
			aes_setkey_enc(&ctx, key, 128 + u * 64);

			for (j = 0; j < 10000; j++) {
				unsigned char tmp[16];

				aes_crypt_cbc(&ctx, v, 16, iv, buf, buf);

				memcpy(tmp, prv, 16);
				memcpy(prv, buf, 16);
				memcpy(buf, tmp, 16);
			}

			if (memcmp(prv, aes_test_cbc_enc[u], 16) != 0) {
				if (verbose != 0)
					printf("failed\n");

				return (1);
			}
		}

		if (verbose != 0)
			printf("passed\n");
	}

	if (verbose != 0)
		printf("\n");

	/*
	 * CFB128 mode
	 */
	for (i = 0; i < 6; i++) {
		u = i >> 1;
		v = i & 1;

		if (verbose != 0)
			printf("  AES-CFB128-%3d (%s): ", 128 + u * 64,
			(v == AES_DECRYPT) ? "dec" : "enc");

		memcpy(iv, aes_test_cfb128_iv, 16);
		memcpy(key, aes_test_cfb128_key[u], 16 + u * 8);

		offset = 0;
		aes_setkey_enc(&ctx, key, 128 + u * 64);

		if (v == AES_DECRYPT) {
			memcpy(buf, aes_test_cfb128_ct[u], 64);
			aes_crypt_cfb128(&ctx, v, 64, &offset, iv, buf, buf);

			if (memcmp(buf, aes_test_cfb128_pt, 64) != 0) {
				if (verbose != 0)
					printf("failed\n");

				return (1);
			}
		}
		else {
			memcpy(buf, aes_test_cfb128_pt, 64);
			aes_crypt_cfb128(&ctx, v, 64, &offset, iv, buf, buf);

			if (memcmp(buf, aes_test_cfb128_ct[u], 64) != 0) {
				if (verbose != 0)
					printf("failed\n");

				return (1);
			}
		}

		if (verbose != 0)
			printf("passed\n");
	}

	if (verbose != 0)
		printf("\n");

	return (0);
}

#endif

#endif
